Here's a quick recap of what we've created in the kubernetes directory:
  * postgres-secret.yaml: Securely stores the database password.
  * postgres-pvc.yaml: Requests persistent storage for the database.
  * postgres-deployment.yaml: A StatefulSet to run the PostgreSQL container.
  * postgres-service.yaml: A Service to allow our backend to connect to the database.

------

âœ¦ Excellent. We have now created the Kubernetes manifests for our backend service.

  Here's a recap of the files we just added to the kubernetes directory:
   * backend-deployment.yaml: A Deployment to run our Node.js backend application.
   * backend-service.yaml: A Service to allow our frontend to communicate with the backend.

  We have now defined the entire backend infrastructure: the PostgreSQL database and the Node.js API.

  The next logical step is to create the frontend application. This will involve:
   1. Creating a simple React application.
   2. Creating a Dockerfile to containerize it with Nginx.
   3. Creating the Kubernetes manifests (Deployment, Service, and Ingress) to run and expose it.

------

 Here is a summary of what we have built:

   * `backend` directory:
       * A Node.js/Express API to shorten URLs.
       * A Dockerfile to containerize the backend.
   * `frontend` directory:
       * A React/Vite UI to interact with the API.
       * A multi-stage Dockerfile to build and serve the frontend with Nginx.
   * `kubernetes` directory:
       * namespace.yaml: To isolate our application.
       * PostgreSQL: postgres-secret.yaml, postgres-pvc.yaml, postgres-deployment.yaml (StatefulSet), and postgres-service.yaml.
       * Backend: backend-deployment.yaml and backend-service.yaml.
       * Frontend: frontend-deployment.yaml, frontend-service.yaml, and ingress.yaml.

  Next Steps: How to Deploy

  You are now ready to build and deploy this application to a Kubernetes cluster. Here is the recommended workflow:

   1. Install Dependencies:
       * Run npm install inside the backend directory.
       * Run npm install inside the frontend directory.

   2. Build Docker Images:
       * You will need a Docker daemon running.
       * Build the backend image: docker build -t shortlink-backend:latest ./backend
       * Build the frontend image: docker build -t shortlink-frontend:latest ./frontend
       * (Optional) If you are using a remote Kubernetes cluster (like GKE, EKS, or AKS), you will need to push these images to a container registry (like Docker Hub or GCR) and update the image fields in the
         backend-deployment.yaml and frontend-deployment.yaml files. If you are using a local cluster like Minikube or Docker Desktop, you can often use local images directly.

   3. Deploy to Kubernetes:
       * Make sure your kubectl is configured to point to your cluster.
       * Apply the manifests in the correct order:

    1         # 1. Create the namespace first
    2         kubectl apply -f kubernetes/namespace.yaml
    3
    4         # 2. Deploy the database components
    5         kubectl apply -f kubernetes/postgres-secret.yaml
    6         kubectl apply -f kubernetes/postgres-pvc.yaml
    7         kubectl apply -f kubernetes/postgres-deployment.yaml
    8         kubectl apply -f kubernetes/postgres-service.yaml
    9
   10         # 3. Deploy the backend
   11         kubectl apply -f kubernetes/backend-deployment.yaml
   12         kubectl apply -f kubernetes/backend-service.yaml
   13
   14         # 4. Deploy the frontend and expose the app
   15         kubectl apply -f kubernetes/frontend-deployment.yaml
   16         kubectl apply -f kubernetes/frontend-service.yaml
   17         kubectl apply -f kubernetes/ingress.yaml

  This tutorial has covered the core concepts of Kubernetes in a practical, hands-on way. You've learned how to manage stateless and stateful applications, handle configuration and secrets, manage storage, and
  expose your application to the world.

# Test port forwarding (recommended for WSL)
kubectl port-forward -n ingress-nginx svc/ingress-nginx-controller 8080:80 &

# Test from inside cluster
kubectl exec -n shortlink <pod-name> -- curl -s http://localhost:80

# Test network connectivity
ping -c 3 192.168.49.2  # This will fail in WSL, that's normal

----
 Now, please follow this exact sequence:

1. Ensure the images are loaded into Minikube (run these again to be safe):

1     minikube image load shortlink-backend:latest
2     minikube image load shortlink-frontend:latest
2. Apply the updated YAML files:
1     kubectl apply -f kubernetes/
3. Restart the deployments one more time:

1     kubectl rollout restart deployment backend-deployment -n shortlink
2     kubectl rollout restart deployment frontend-deployment -n shortlink

--
check logs

kubectl logs -n shortlink -l app=frontend
kubectl logs -n shortlink -l app=backend

---
port forwarding

kubectl get pods -n ingress-nginx
kubectl port-forward --namespace ingress-nginx ingress-nginx-controller-9cc49f96f-shsvf 8080:80
kubectl logs -f ingress-nginx-controller-9cc49f96f-shsvf -n ingress-nginx